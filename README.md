# Operation-System
下面是我在学习操作系统中写的一些操作系统常用算法  <br>
写于2018年 大二上学期  我对它们进行了整理  <br>
通过敲完这些算法 会让你更理解操作系统的原理 <br>
使用 VC6.0 和 CB环境都行 <br>
纯C语言编写  <br>

<img src="img/01.PNG"/>
###银行家算法自然语言描述：<br>
设 Requesti是进程 Pi的请求向量，如果 Requesti［j］=K，表示进程 Pi需要 K 个 Rj类型<br>
的资源。当 Pi发出资源请求后，系统按下述步骤进行检查：<br>
(1) 如果 Requesti［j］≤Need［i,j］，便转向步骤 2；否则认为出错，因为它所需要的资源数<br>
已超过它所宣布的最大值。
(2) 如果 Requesti［j］≤Available［j］，便转向步骤(3)；否则， 表示尚无足够资源，Pi 须等
待。<br>
(3) 系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：<br>
Available［j］=Available［j］-Requesti［j］;<br>
Allocation［i,j］=Allocation［i,j］+Requesti［j］;<br>
Need［i,j］=Need［i,j］-Requesti［j］;<br>
(4) 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式<br>
将资源分配给进程 Pi，以完成本次分配；否则， 将本次的试探分配作废，恢复原来的<br>
资源分配状态，让进程 Pi等待。<br/>

<img src="img/02.PNG">

<br>
安全性算法自然语言描述：<br>
(1) 设置两个向量：① 工作向量 Work: 它表示系统可提供给进程继续运行所需的各类资源<br>
数目，它含有 m 个元素，在执行安全算法开始时，Work∶=Available; ② Finish: 它表示<br>
系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish［i］∶=false; 当<br>
有足够资源分配给进程时， 再令 Finish［i］∶=true。<br>
(2) 从进程集合中找到一个能满足下述条件的进程：<br>
① Finish［i］=false; ② Need［i,j］≤Work［j］； 若找到， 执行步骤(3)， 否则，执行<br>
步骤(4)<br>
(3) 当进程 Pi 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>
Work［j］∶ ［i］+Allocation［i,j］<br>
Finish［i］∶<br>
go to step (2);<br>
(4) 如果所有进程的 Finish［i］=true 都满足， 则表示系统处于安全状态；否则，系统处于<br>
不安全状态。<br>

###模拟先来先服务（FCFS）调度算法
按照 FCFS 调度进程 <br>
 动态地输入进程(key,sequence,message)，按照输入次序建立队列<br>
 按照 FCFS 的次序模拟进程逐个被调度并进入 CPU 运行的过程<br>
<br>

###模拟进程优先级调度<br>
1. 按照优先级出列<br>
 动态地输入进程，按照输入次序建立队列<br>
 按照优先级的次序将队列中的进程逐个出队<br>
 2. 按照优先级入列<br>
 动态地输入进程，按照优先级建立优先级队列<br>
 按照前后次序将队列中的进程逐个出队<br>

###模拟时间片轮转调度算法<br>
按照时间片轮转调度进程<br>
 动态地输入进程(key,run_time,message)，按照输入次序建立就绪队列<br>
 输入 CPU 运行的单位时间片(cpu_base_time)<br>
 按照时间片轮转方式模拟进程逐个被调度并执行单位时间片(运行结束进程结束，否则<br>
修改进程运行时间 run_time,将该进程放置在就绪队列尾巴)。<br>

###模拟首次适应（First Fit）算法<br>
 首次适应算法 FF(First Fit)<br>
 基本思想：要求空闲分区按地址递增的次序排列。当进行内存分配时，从空闲区表<br>
头开始顺序查找，直到找到第一个能满足其大小要求的空闲区为止。分一块给请求<br>
者，余下部分仍留在空闲区中。<br>
实例：某系统内存容量为 800K，下面分别给出中的空闲分区表和分配分区表，系统采用动<br>
态分区存储管理策略。现有以下作业序列：96K（作业名：A），20K（作业名：B），200K（作<br>
业名：C）。请用首次适应 FF 算法来处理这些作业序列，并打印出该算法分配空间后的空闲<br>
分区表和分配分区表。(若出现内存不足的情况，请提示作业等待内存资源)<br>
分配分区表：<br>
作业名 大小 起始地址<br>
OS 60K 0 K<br>
Task1 40K 60K<br>
Task2 18K 132K<br>
Task3 40K 160K<br>
Task4 15K 205K<br>
Task5 92K 438K<br>
Task6 174K 626K<br>
空闲分区表：<br>
大小 起始地址<br>
32K 100K<br>
10K 150K<br>
5K 200K<br>
218K 220K<br>
96K 530K<br>
按照 FF 算法分配内存：<br>
 动态地任意顺序输入“分配分区表项”，按照地址递增方式建立“分配分区表”<br>





